// @suite: Feature: func



// @test: Basic usage
// @typecheck
// ============================================================================

class Foo {
    func f( _ a: number              ): string { return "f(_:)";   }
    func f(   a: number              ): string { return "f(a:)";   }
    func f(   a: number,   b: number ): string { return "f(a:b:)"; }
    func f( _ a: number,   b: number ): string { return "f(_:b:)"; }

    func f(_ a: number, _ b: number, c: number): string { return "f(_:_:c:)"; }

    func noArg(): string { return "noArg()"; }
}

let foo = new Foo();

assert.equal(foo.f(   42       ), "f(_:)");
assert.equal(foo.f(a: 42       ), "f(a:)");
assert.equal(foo.f(a: 42, b: 42), "f(a:b:)");
assert.equal(foo.f(   42, b: 42), "f(_:b:)");
assert.equal(foo.f(42, 42, c: 42), "f(_:_:c:)");

assert.equal(foo.noArg(), "noArg()");


// @test: Co-exist with class method
// ============================================================================

class Foo {
    func f(a: number): string { return "f(a:)";   }
    f(): string { return "f()"; }
}

let foo = new Foo();
assert.equal(foo.f(   42       ), "f()");
assert.equal(foo.f(a: 42       ), "f(a:)");


// @test: Check parser override
// ============================================================================

// To implement named parameters in call syntax, we have to override acorn's
// parseExprList() parser method. Check some edge cases here.

let arr1 = [ 1, 2, 3, ]
assert.strictEqual(arr1.length, 3);

let arr2 = [ , , ]
assert.strictEqual(arr2.length, 2);
assert.strictEqual(arr2[0], undefined);
assert.strictEqual(arr2[1], undefined);

function foo(a, b, c, d, e) {
    assert.equal(a, "A");
    assert.equal(b, "B");
    assert.equal(c, "C");
    assert.equal(d, "D");
    assert.strictEqual(e, undefined);
}

foo("A", ...[ "B", "C", "D" ]);

