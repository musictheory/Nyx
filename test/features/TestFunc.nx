// @suite: Feature: func



// @test: Basic usage
// @typecheck
// ============================================================================

class Foo {
    func f( _ a: number              ): string { return "f(_:)";   }
    func f(   a: number              ): string { return "f(a:)";   }
    func f(   a: number,   b: number ): string { return "f(a:b:)"; }
    func f( _ a: number,   b: number ): string { return "f(_:b:)"; }

    func f(_ a: number, _ b: number, c: number): string { return "f(_:_:c:)"; }

    func f(c): string { return "f(c:)"; } // @type

    func noArg(): string { return "noArg()"; }
}

let foo = new Foo();

assert.equal(foo.f(   42       ), "f(_:)");
assert.equal(foo.f(a: 42       ), "f(a:)");
assert.equal(foo.f(a: 42, b: 42), "f(a:b:)");
assert.equal(foo.f(   42, b: 42), "f(_:b:)");
assert.equal(foo.f(42, 42, c: 42), "f(_:_:c:)");

assert.equal(foo.f(c: {}), "f(c:)");

assert.equal(foo.noArg(), "noArg()");



// @test: Async func
// @typecheck
// ============================================================================

class Foo {
    async func asyncF(a: number) { }
    static async func asyncF(a: number) { }
}

let foo = new Foo();
assert.equal(typeof Foo.asyncF(a: 1).then, "function");
assert.equal(typeof foo.asyncF(a: 1).then, "function");



// @test: Co-exist with class method
// ============================================================================

class Foo {
    func f(a: number): string { return "f(a:)";   }
    f(): string { return "f()"; }
}

let foo = new Foo();
assert.equal(foo.f(   42       ), "f()");
assert.equal(foo.f(a: 42       ), "f(a:)");



// @test: Keyword as func base name
// ============================================================================

class Foo {
    func for():            string { return "for()"; }
    func for(a: number):   string { return "for(a:)"; }

    func let(_ a: number): string { return "let(_:)"; }
    func let(a: number):   string { return "let(a:)"; }
}

let foo = new Foo();
assert.equal(foo.for(),      "for()");
assert.equal(foo.for(a: 42), "for(a:)");
assert.equal(foo.let(42),    "let(_:)");
assert.equal(foo.let(a: 42), "let(a:)");



// @test: 'func' as name of method
// ============================================================================

class Foo {
    func(a: number): string { return "Foo"; }
}

assert.equal((new Foo()).func(42), "Foo");



// @test: 'func' generator
// ============================================================================

class Foo {
    func *gen(times: number) {
        for (let i = 0; i < times; i++) {
            yield "Foo";
        }
    }

    async func *asyncGen(times: number) { }
}

let f = new Foo();

assert.deepStrictEqual(
    Array.from(f.gen(times: 3)),
    ["Foo", "Foo", "Foo" ]
);

assert.equal(typeof f.asyncGen(times: 1).next().then, "function");



// @test: Check parser override
// ============================================================================

// To implement named parameters in call syntax, we have to override acorn's
// parseExprList() parser method. Check some edge cases here.

let arr1 = [ 1, 2, 3, ]
assert.strictEqual(arr1.length, 3);

let arr2 = [ , , ]
assert.strictEqual(arr2.length, 2);
assert.strictEqual(arr2[0], undefined);
assert.strictEqual(arr2[1], undefined);

function foo(a, b, c, d, e) {
    assert.equal(a, "A");
    assert.equal(b, "B");
    assert.equal(c, "C");
    assert.equal(d, "D");
    assert.strictEqual(e, undefined);
}

foo("A", ...[ "B", "C", "D" ]);


// @test: Error on optional parameter
// ============================================================================

class Foo {
    func foo(bar?: string) { } // @error
}

