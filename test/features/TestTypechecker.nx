// @suite: Feature: Typechecker

// @test: Basic Usage
// @typecheck
// ============================================================================

let s: string = 4; //@type


type RectNumber = number;

interface Rect {
    x: RectNumber;
    y: RectNumber;
    width: number;
    height: number;
}



// @test: readonly modifier
// @typecheck
// ============================================================================

// Test "readonly" modifier of class field

class Foo {
    static readonly s: string;
    readonly x: string;
}

let f = new Foo();
f.x = "bar"; // @type

Foo.s = "bar"; // @type



// @test: interface optional field
// @typecheck
// ============================================================================

interface Point   { x: number; y: number; z?: number }
interface Point2D { x: number; y: number }
interface Point3D { x: number; y: number; z: number }

// Test optional method syntax
interface IFoo { maybeFunction?(): string; }
let f: IFoo = { }; f.maybeFunction?.();

let alpha:   Point = { x: 1, y: 2 };
let alpha3D: Point = { x: 1, y: 2, z: 3 };

let beta:   Point3D = { x: 1, y: 2 }; // @type
let beta3D: Point3D = { x: 1, y: 2, z: 3 };

function takesPoint(p: Point) { }
function takesPoint2D(p: Point2D) { }
function takesPoint3D(p: Point3D) { }

takesPoint(  alpha); takesPoint(  alpha3D); takesPoint(  beta); takesPoint(  beta3D);
takesPoint2D(alpha); takesPoint2D(alpha3D); takesPoint2D(beta); takesPoint2D(beta3D);

takesPoint3D(alpha);   // @type
takesPoint3D(alpha3D); // @type
takesPoint3D(beta);
takesPoint3D(beta3D);



// @test: 'as' expression
// @typecheck
// ============================================================================

enum Foo { foo, bar, baz };
enum Bar { foo, bar, baz };

function takesBar(x: Bar) { }
let x: Foo = Foo.foo;
takesBar(x as number as Bar);



// @test: postfix '!'
// @typecheck
// ============================================================================

function actuallyReturnsNonNullString(): string | null {
    return "foo";
}

function takesNonNullString(x: string): void { }

let x1 = actuallyReturnsNonNullString();
let x2 = actuallyReturnsNonNullString();

takesNonNullString(x1); // @type
takesNonNullString(x2!);



// @test: type predicates
// @typecheck
// ============================================================================

function isArray(x: any): x is any[]
{
    return Array.isArray(x);
}

let x = { }, y = 0;
if (isArray(x)) y += x.length;



// @test: Test 'extends' on 'interface'
// @typecheck
// ============================================================================

interface IFoo { foo(): string }
interface IBar { bar(): string }

interface IFooBar extends IFoo, IBar { }

class FooBar {
    foo() { return "foo"; }
    bar() { return "bar"; }
}

let fooBar = new FooBar() as IFooBar;
fooBar.foo();
fooBar.bar();
assert.throws(() => fooBar.baz()); // @type



// @test: Allow void annotation on setter
// @typecheck
// ============================================================================

class Foo {
    #foo: string;
    get foo(): string { return this.#foo; }

    #bar: string;
    get bar(): string { return this.#bar; }

    // 'void' is ok and Nyx will strip it
    set foo(x: string): void { this.#foo = x; }

    // Anything else will not be stripped and TS will warn
    set bar(x: string): string[] { this.#bar = x; } // @type
}



// @test: Test 'type' as function
// @typecheck
// ============================================================================

function type(x: string) {
    assert.equal(x, "Foo");
    return "Bar";
}

assert.equal(type("Foo"), "Bar");



// @test: '?' nullable type
// @typecheck
// ============================================================================

let foo: string? = null;
let bar: string? = undefined; // @type
let baz: string? = 5; // @type
let moo: string? = "moo";

let t1: [ (string?), string? ] = [ null, undefined ];
let t2: [ (string?), string? ] = [ null ];
let t3: [ string? ]            = [ null ]; //@type
let t4: [ string  ]            = [ null ]; //@type



// @test: Conditional Types
// @typecheck
// ============================================================================

class Animal { live() { } }
class Cow extends Animal { moo() { } }

function f(x: Cow extends Animal ? string : number): void { }

f("moo"); // ok
f(42); // @type



// @test: Infer Type
// @typecheck
// ============================================================================

type GetReturnType<T> = T extends (...args: never[]) => infer R ? R : never;

function f(x: GetReturnType<() => string>): void { }

f("moo"); // ok
f(42); // @type



// @test: Type Parameters
// @typecheck
// ============================================================================

function takesString(x: string) { }
function takesIdentity(x: <T>(x: T) => T) { }


// Test basic type parameters
{
    function identity<T>(x: T): T { return x; }

    const identity2 = function <T>(x: T): T { return x; }

    class Identity {
        static identity<T>(x: T): T { return x; }
        identity<T>(x: T): T { return x; }
    }

    let i = new Identity();
    takesString(i.identity("foo"));
    takesString(Identity.identity("foo"));
    takesString(identity("foo"));
    takesString(identity2("foo"));

    takesIdentity(i.identity);
    takesIdentity(Identity.identity);
    takesIdentity(identity);
    takesIdentity(identity2);
}


// Class with multiple parameters, 'extends Class<T>'
{
    class Foo<T, U> { check(a: T, b: U) { } }
    class Bar extends Foo<bigint, bigint> { }

    let f1 = new Foo<string, number>();
    let f2 = new Foo<number, string>();

    f1.check("foo", 42);
    f1.check("foo",
        "foo"); // @type

    f2.check(42, "foo");
    f2.check("foo", 42); // @type


    let bar = new Bar();
    bar.check(42n, 42n);
    bar.check(42n,
        "foo"); // @type
}


// const modifier
{
    function constIdentity<const T>(x: T) { return x; }

    class ConstIdentity {
        constIdentity<const T>(x: T): T { return x; }
    }

    let i = new ConstIdentity();

    let x1 = constIdentity({ x: 42 });
    x1.x = 157; // @type

    let x2 = i.constIdentity({ x: 42 });
    x2.x = 157; // @type
}


// in/out modifier
{
    interface Consumer<in T> { }
    interface Producer<out T> { }
    interface ProducerConsumer<in out T> { }
}


// Test 'extends', 'infer', and conditional types
{
    function string_number(a: string, b: number) { }
    function number_string(a: number, b: string) { }

    type FirstArg<T> = T extends (first: infer U, ...args: any[]) => any ? U : never;

    function returns_string(): FirstArg<typeof string_number> { return "x"; }
    function returns_number(): FirstArg<typeof number_string> { return 42; }

    takesString(returns_string());
    takesString(returns_number()); // @type

    type FirstIfString<T> = T extends [infer S extends string, ...unknown[]] ? S : symbol;

    function returns_string2(): FirstIfString<[string, number]> { return "x"; }
    function returns_symbol():  FirstIfString<[number, string]> { return Symbol(); }

    takesString(returns_string2());
    takesString(returns_symbol()); // @type
}


// Test type parameter with constraint
{
    class Foo { foo() { } }

    function takesFoo(foo: Foo) { }

    type TypeMap = { "foo": Foo }

    function create<T extends keyof TypeMap>(name: T): TypeMap[T]
    {
        if (name == "foo") return new Foo();
        else throw new Error();
    }

    takesFoo(create("foo"));
}



// @test: Edge cases
// @typecheck
// ============================================================================


// Check special case where type annotation is before <
assert.equal({ } as any as number < 42, false);



// @test: Error - Empty Type Parameters
// ============================================================================

class Foo<> { } // @error

